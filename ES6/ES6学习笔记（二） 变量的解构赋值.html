<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Joey Studio</title>
    <meta name="description" content="Joey Studio">
    <link rel="icon" href="/icon.png">
    
    <link rel="preload" href="/assets/css/0.styles.fb6ef450.css" as="style"><link rel="preload" href="/assets/js/app.6496ed3f.js" as="script"><link rel="preload" href="/assets/js/15.a62e713d.js" as="script"><link rel="prefetch" href="/assets/js/2.154dcc5e.js"><link rel="prefetch" href="/assets/js/3.2d1485e9.js"><link rel="prefetch" href="/assets/js/4.bff3c410.js"><link rel="prefetch" href="/assets/js/5.dae9ed13.js"><link rel="prefetch" href="/assets/js/6.0e78168f.js"><link rel="prefetch" href="/assets/js/7.080d07e2.js"><link rel="prefetch" href="/assets/js/8.b51527e8.js"><link rel="prefetch" href="/assets/js/9.47e0dfdd.js"><link rel="prefetch" href="/assets/js/10.df869b81.js"><link rel="prefetch" href="/assets/js/11.ca769e48.js"><link rel="prefetch" href="/assets/js/12.054daf01.js"><link rel="prefetch" href="/assets/js/13.a59e5c03.js"><link rel="prefetch" href="/assets/js/14.0b0c8a1d.js"><link rel="prefetch" href="/assets/js/16.1f5c82f7.js"><link rel="prefetch" href="/assets/js/17.12cc41fd.js"><link rel="prefetch" href="/assets/js/18.9a24a91a.js"><link rel="prefetch" href="/assets/js/19.f6abe518.js"><link rel="prefetch" href="/assets/js/20.e65b6931.js"><link rel="prefetch" href="/assets/js/21.0b676c70.js"><link rel="prefetch" href="/assets/js/22.439a1331.js"><link rel="prefetch" href="/assets/js/23.ba536dc8.js"><link rel="prefetch" href="/assets/js/24.c320b32b.js"><link rel="prefetch" href="/assets/js/25.3e421fe3.js"><link rel="prefetch" href="/assets/js/26.2231c0ca.js"><link rel="prefetch" href="/assets/js/27.bcc817c1.js"><link rel="prefetch" href="/assets/js/28.c2c3d444.js"><link rel="prefetch" href="/assets/js/29.2ead0a19.js"><link rel="prefetch" href="/assets/js/30.1255fe73.js"><link rel="prefetch" href="/assets/js/31.560e43a1.js"><link rel="prefetch" href="/assets/js/32.4763ce13.js"><link rel="prefetch" href="/assets/js/33.f65b93ac.js"><link rel="prefetch" href="/assets/js/34.503ff2e4.js"><link rel="prefetch" href="/assets/js/35.abff669d.js"><link rel="prefetch" href="/assets/js/36.aa126b1a.js"><link rel="prefetch" href="/assets/js/37.92bebcb1.js"><link rel="prefetch" href="/assets/js/38.c3c64b7f.js"><link rel="prefetch" href="/assets/js/39.d86c8f5e.js"><link rel="prefetch" href="/assets/js/40.17162130.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fb6ef450.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Joey Studio</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/Web/" class="nav-link">工具</a></div><div class="nav-item"><a href="/JVM/" class="nav-link">JVM</a></div><div class="nav-item"><a href="/SpringCloud/" class="nav-link">微服务</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/slowside45" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/Web/" class="nav-link">工具</a></div><div class="nav-item"><a href="/JVM/" class="nav-link">JVM</a></div><div class="nav-item"><a href="/SpringCloud/" class="nav-link">微服务</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/slowside45" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </div> <div class="page"> <div class="content"><p>[TOC]</p> <h2 id="解构"><a href="#解构" aria-hidden="true" class="header-anchor">#</a> 解构</h2> <p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p> <h3 id="_1-基本用法"><a href="#_1-基本用法" aria-hidden="true" class="header-anchor">#</a> 1. 基本用法</h3> <p><strong>要义：</strong></p> <ul><li>模式匹配</li> <li>等号左边的对象个数 &gt;= 等号右边的变量个数</li> <li>等号右边的变量需要具有Iterator接口（可迭代结构）</li></ul> <h3 id="_2-解构类型"><a href="#_2-解构类型" aria-hidden="true" class="header-anchor">#</a> 2. 解构类型</h3> <h5 id="_1-完全解构"><a href="#_1-完全解构" aria-hidden="true" class="header-anchor">#</a> (1)完全解构</h5> <p>等号两边只要模式匹配，就能从对应的位置提取值，对变量进行赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>let [a,b,c] = [0,1,2];
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let [a,[b,[c]]] = [0,[1,[2]]]; //a=0,[b,[c]] = [1,[2]]; 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let [startPar, ...endPar] = [0,1,2]; // startPar = 0; endPar = [1,2]
...是占位符，表示出了第一个变量后面的所有变量
</code></pre></div><h5 id="_2-解构不成功"><a href="#_2-解构不成功" aria-hidden="true" class="header-anchor">#</a> (2)解构不成功</h5> <div class="language- extra-class"><pre class="language-text"><code>let [x,y, ...z] = [&quot;a&quot;]; /*x = 'a';y=undefined(没有对应的位置给y赋值)
                           z = [];(...z表示第一个值后的所有值)*/
</code></pre></div><p>若解构不成功，则没有在对应位置给等号右边的变量赋值，变量的值将会是undefined.</p> <h5 id="_3-不完全解构"><a href="#_3-不完全解构" aria-hidden="true" class="header-anchor">#</a> (3)不完全解构</h5> <p>等号左边只有一部分匹配等号右边的模式，这时也能完成解构。</p> <div class="language- extra-class"><pre class="language-text"><code>let [x,y] = [1,2,3]; //x=1;y=2
</code></pre></div><h5 id="_4-不可迭代的数据类型"><a href="#_4-不可迭代的数据类型" aria-hidden="true" class="header-anchor">#</a> (4)不可迭代的数据类型</h5> <p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</code></pre></div><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p> <h3 id="_3-默认值"><a href="#_3-默认值" aria-hidden="true" class="header-anchor">#</a> 3. 默认值</h3> <ul><li><strong>解构赋值允许设置默认值。</strong></li> <li><strong>只有等号右边的数组成员变量 === undifined，默认值才会生效</strong></li> <li><strong>当等号右边变量为等号左边数组成员赋值时，默认值失效</strong></li></ul> <div class="language- extra-class"><pre class="language-text"><code>let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre></div><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p> <div class="language- extra-class"><pre class="language-text"><code>let [x=1,y=x] = [2]; //x=2;y=2;
</code></pre></div><p>上面代码中，默认值可以引用解构赋值了的其他变量，前提是其他变量已经被声明。</p> <p>而在等号右边，2被赋给了x，x=1（默认值）将不会生效。</p> <h3 id="_4-对象的解构赋值"><a href="#_4-对象的解构赋值" aria-hidden="true" class="header-anchor">#</a> 4. 对象的解构赋值</h3> <p>要义：</p> <ul><li>键值对 -- 等号左右变量名称对应方可赋值, 次序可以不一致</li></ul> <h5 id="（1）名称不对应的解构赋值"><a href="#（1）名称不对应的解构赋值" aria-hidden="true" class="header-anchor">#</a> （1）名称不对应的解构赋值</h5> <div class="language- extra-class"><pre class="language-text"><code>let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre></div><p>上面代码中，baz是匹配模式，变量中没有与之对应的变量。所以baz取不到值，解构失败。</p> <p>如果变量名与属性名不一致，必须写成下面这样。</p> <div class="language- extra-class"><pre class="language-text"><code>let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // &quot;aaa&quot;

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
</code></pre></div><p>对象的解构赋值是下面形式的简写。</p> <div class="language- extra-class"><pre class="language-text"><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre></div><hr> <div class="language- extra-class"><pre class="language-text"><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre></div><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p> <p>==可以理解为：foo是类，baz是对象，等号右边的foo:&quot;aaa&quot;是 baz = aaa;==</p> <h5 id="_2-默认值"><a href="#_2-默认值" aria-hidden="true" class="header-anchor">#</a> (2)默认值</h5> <p>对象的解构也可以指定默认值。</p> <div class="language- extra-class"><pre class="language-text"><code>var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5，这个代码中，x是匹配模式，y是变量，等号右边其实是给y赋值，所以最后y=5

var { message: msg = 'Something went wrong' } = {};
msg // &quot;Something went wrong&quot;
</code></pre></div><p>默认值生效的条件是，对象的属性值严格等于undefined。</p> <h5 id="（3）解构提前声明好的变量"><a href="#（3）解构提前声明好的变量" aria-hidden="true" class="header-anchor">#</a> （3）解构提前声明好的变量</h5> <p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p> <div class="language- extra-class"><pre class="language-text"><code>// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</code></pre></div><ul><li>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 正确的写法
let x;
({x} = {x: 1});
</code></pre></div><h5 id="_4-等号左边的模式中不放置任何变量"><a href="#_4-等号左边的模式中不放置任何变量" aria-hidden="true" class="header-anchor">#</a> (4)等号左边的模式中不放置任何变量</h5> <ul><li>在等号左边，只写模式，不写对应的变量。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>({} = [true, false]);
({} = 'abc');
({} = []);
</code></pre></div><ul><li>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。
对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let { log, sin, cos } = Math;
</code></pre></div><ul><li>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</li></ul> <h5 id="_5-数组的解构赋值"><a href="#_5-数组的解构赋值" aria-hidden="true" class="header-anchor">#</a> (5)数组的解构赋值</h5> <p>数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
0 --&gt; 1; 1 --&gt; 2; 2 --&gt; 3
</code></pre></div><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3.</p> <h5 id="_6-字符串的解构赋值"><a href="#_6-字符串的解构赋值" aria-hidden="true" class="header-anchor">#</a> (6)字符串的解构赋值</h5> <ul><li>字符串在被解构赋值时，实际上是被转换成了一个类似于数组的对象。
等号左边每一个数组成员变量，根据位置与右边变量一一对应。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const [a,b,c,d,e] = &quot;hello&quot;;
a // 'h';
b // 'e';
c // 'l';
d // 'l';
e // 'o';
</code></pre></div><ul><li>类似数组的对象都有一个length属性，可以对这个属性解构赋值：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let {length: len} = 'hello';
len //5;
</code></pre></div><h5 id="_7-数值和布尔值的解构赋值"><a href="#_7-数值和布尔值的解构赋值" aria-hidden="true" class="header-anchor">#</a> (7)数值和布尔值的解构赋值</h5> <ul><li>解构赋值中，如果等号右边的变量不是对象，就会将它们先转换成变量，再进行解构赋值。</li></ul> <h5 id="_8-函数参数的解构"><a href="#_8-函数参数的解构" aria-hidden="true" class="header-anchor">#</a> (8)函数参数的解构</h5> <p>==Map方法的用法==</p> <div class="language- extra-class"><pre class="language-text"><code>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
map() 方法按照原始数组元素顺序依次处理元素。
注意： map() 不会对空数组进行检测。
注意： map() 不会改变原始数组。
</code></pre></div><p>==解构函数的参数==</p> <div class="language- extra-class"><pre class="language-text"><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre></div><ul><li><p>在这个例子中，([a,b]) =&gt; a+b 等同于 function([a,b]){ return a+b; }</p></li> <li><p>map方法的作用是改变前面的数组，经过函数处理后，返回一个新数组。</p></li></ul> <h5 id="_9-不能使用圆括号的解构赋值"><a href="#_9-不能使用圆括号的解构赋值" aria-hidden="true" class="header-anchor">#</a> (9)不能使用圆括号的解构赋值</h5> <p>==① 变量声明语句==</p> <div class="language- extra-class"><pre class="language-text"><code>// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
</code></pre></div><p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p> <p>==② 函数参数==</p> <p>函数参数也属于变量声明，因此不能带有圆括号。</p> <div class="language- extra-class"><pre class="language-text"><code>// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
</code></pre></div><p>==③ 赋值语句的模式==</p> <div class="language- extra-class"><pre class="language-text"><code>// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
上面代码将整个模式放在圆括号之中，导致报错。

// 报错
[({ p: a }), { x: c }] = [{}, {}];
上面代码将一部分模式放在圆括号之中，导致报错。
</code></pre></div><h5 id="_10-可以使用圆括号的情况"><a href="#_10-可以使用圆括号的情况" aria-hidden="true" class="header-anchor">#</a> (10)可以使用圆括号的情况</h5> <ul><li>当圆括号内不是模式部分时，不会报错。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre></div><ul><li>第一条，(b)是实际要被赋值的变量，不是模式成员</li> <li>第二条，同上，模式是p，变量是d</li> <li>第三条，同上</li></ul> <h3 id="_5-解构赋值的实际用法"><a href="#_5-解构赋值的实际用法" aria-hidden="true" class="header-anchor">#</a> 5. 解构赋值的实际用法</h3> <h5 id="_1-交换两个变量的值"><a href="#_1-交换两个变量的值" aria-hidden="true" class="header-anchor">#</a> (1)交换两个变量的值</h5> <p>在ES6中：</p> <div class="language- extra-class"><pre class="language-text"><code>let x = 1;
let y = 2;
[x,y] = [y,x];
</code></pre></div><p>在普通js中：</p> <div class="language- extra-class"><pre class="language-text"><code>var x = 1;
var y = 2;
var cache;
var cache = x;
var x = y;
var y = cache;
</code></pre></div><p>==相比较起来，ES6中的解构赋值功能让代码更清晰，简洁==</p> <h5 id="_2-从函数返回多个值后，接收这些值"><a href="#_2-从函数返回多个值后，接收这些值" aria-hidden="true" class="header-anchor">#</a> (2)从函数返回多个值后，接收这些值</h5> <p>在ES6中:</p> <div class="language- extra-class"><pre class="language-text"><code>function eg(){
    return [1,2,3];
}
let [a,b,c] = eg(); //接收起来很简单,abc都有了自己对应的值
</code></pre></div><p>在普通js中：</p> <div class="language- extra-class"><pre class="language-text"><code>function eg(){
    return [1,2,3]
}
var arr[] = eg();
var a = arr[0];
var b = arr[1];
var c = arr[2];  //接收需要从数组里挨个取值
</code></pre></div><h5 id="_3-调用函数时，给函数传参"><a href="#_3-调用函数时，给函数传参" aria-hidden="true" class="header-anchor">#</a> (3)调用函数时，给函数传参</h5> <p>在ES6中：</p> <div class="language- extra-class"><pre class="language-text"><code>function eg([x,y,z]){...}
eg([1,2,3]);

eg({z:3,y=2,x=1})
</code></pre></div><ul><li>上面做了两种不一样的函数调用，第二种是无序地传入参数。</li></ul> <p>在普通js中：
只能有序地传入参数</p> <h5 id="_4-取json数据"><a href="#_4-取json数据" aria-hidden="true" class="header-anchor">#</a> (4)取JSON数据</h5> <div class="language- extra-class"><pre class="language-text"><code>let jsonData = {
    id: 1,
    status: 'OK',
    date: [2018,6]
}

let {id,status,date} = jsonData;
console.log(id,status,date); 
</code></pre></div><p>==结果为：id=1;status='OK',date=[2018,6]==</p> <h5 id="_5-为函数参数设定默认值"><a href="#_5-为函数参数设定默认值" aria-hidden="true" class="header-anchor">#</a> (5)为函数参数设定默认值</h5> <p>==1. 给参数设定默认值后，就不用再在函数内做配置。==</p> <div class="language- extra-class"><pre class="language-text"><code>jQuery.ajax() = function (url,{
    async = true,
    beforeSend() = function(){},
    cache = true,
    complete = function(){},
    crossDomail = false,
    global = true
    //...更多配置
} = {}) {
    //函数执行方法...
}
</code></pre></div><p>==2. 对比两种不同写法，在传参不同的情况下，函数的输出值==</p> <div class="language- extra-class"><pre class="language-text"><code>// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</code></pre></div><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p> <div class="language- extra-class"><pre class="language-text"><code>// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre></div><p>==3. 参数默认值的位置==</p> <ul><li>通常情况下，应该给函数的尾参数定义默认值，因为这样比较容易看出来省略了哪些参数。如果非尾部的参数被设定了默认值，则不能在调用函数，传参时省略它。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function f(x=1,y){
    return [x,y]
}
f() //[1,undefined]
f(2) //[2,undefined]
f(, 1) //报错
f(undefined,1) //[1,1]
</code></pre></div><p>==在这些函数中，有默认值的都不是尾参数，所以不能只省略它们，而不省略后面的参数。除非显示输入undefined==</p> <h5 id="_6-遍历map结构"><a href="#_6-遍历map结构" aria-hidden="true" class="header-anchor">#</a> (6)遍历Map结构</h5> <div class="language- extra-class"><pre class="language-text"><code>const map = new Map();
map.set = {'first','lee'};
map.set = {'second','floyd'};

for (let[key,value] of map){
    console.log(key + 'is' + value);
}
</code></pre></div><p>输出结果为：first is le /n  second is floyd</p> <ul><li>只获取key或只获取value:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 只获取键名
for (let [key] of map){
    console.log(key);
}
// 只获取键值
for (let [,value] of map){
    console.log(value);
}
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/15.a62e713d.js" defer></script><script src="/assets/js/app.6496ed3f.js" defer></script>
  </body>
</html>
