<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Joey Studio</title>
    <meta name="description" content="Joey Studio">
    <link rel="icon" href="/icon.png">
    
    <link rel="preload" href="/assets/css/0.styles.fb6ef450.css" as="style"><link rel="preload" href="/assets/js/app.6496ed3f.js" as="script"><link rel="preload" href="/assets/js/18.9a24a91a.js" as="script"><link rel="prefetch" href="/assets/js/2.154dcc5e.js"><link rel="prefetch" href="/assets/js/3.2d1485e9.js"><link rel="prefetch" href="/assets/js/4.bff3c410.js"><link rel="prefetch" href="/assets/js/5.dae9ed13.js"><link rel="prefetch" href="/assets/js/6.0e78168f.js"><link rel="prefetch" href="/assets/js/7.080d07e2.js"><link rel="prefetch" href="/assets/js/8.b51527e8.js"><link rel="prefetch" href="/assets/js/9.47e0dfdd.js"><link rel="prefetch" href="/assets/js/10.df869b81.js"><link rel="prefetch" href="/assets/js/11.ca769e48.js"><link rel="prefetch" href="/assets/js/12.054daf01.js"><link rel="prefetch" href="/assets/js/13.a59e5c03.js"><link rel="prefetch" href="/assets/js/14.0b0c8a1d.js"><link rel="prefetch" href="/assets/js/15.a62e713d.js"><link rel="prefetch" href="/assets/js/16.1f5c82f7.js"><link rel="prefetch" href="/assets/js/17.12cc41fd.js"><link rel="prefetch" href="/assets/js/19.f6abe518.js"><link rel="prefetch" href="/assets/js/20.e65b6931.js"><link rel="prefetch" href="/assets/js/21.0b676c70.js"><link rel="prefetch" href="/assets/js/22.439a1331.js"><link rel="prefetch" href="/assets/js/23.ba536dc8.js"><link rel="prefetch" href="/assets/js/24.c320b32b.js"><link rel="prefetch" href="/assets/js/25.3e421fe3.js"><link rel="prefetch" href="/assets/js/26.2231c0ca.js"><link rel="prefetch" href="/assets/js/27.bcc817c1.js"><link rel="prefetch" href="/assets/js/28.c2c3d444.js"><link rel="prefetch" href="/assets/js/29.2ead0a19.js"><link rel="prefetch" href="/assets/js/30.1255fe73.js"><link rel="prefetch" href="/assets/js/31.560e43a1.js"><link rel="prefetch" href="/assets/js/32.4763ce13.js"><link rel="prefetch" href="/assets/js/33.f65b93ac.js"><link rel="prefetch" href="/assets/js/34.503ff2e4.js"><link rel="prefetch" href="/assets/js/35.abff669d.js"><link rel="prefetch" href="/assets/js/36.aa126b1a.js"><link rel="prefetch" href="/assets/js/37.92bebcb1.js"><link rel="prefetch" href="/assets/js/38.c3c64b7f.js"><link rel="prefetch" href="/assets/js/39.d86c8f5e.js"><link rel="prefetch" href="/assets/js/40.17162130.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fb6ef450.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Joey Studio</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/Web/" class="nav-link">工具</a></div><div class="nav-item"><a href="/JVM/" class="nav-link">JVM</a></div><div class="nav-item"><a href="/SpringCloud/" class="nav-link">微服务</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/slowside45" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/Web/" class="nav-link">工具</a></div><div class="nav-item"><a href="/JVM/" class="nav-link">JVM</a></div><div class="nav-item"><a href="/SpringCloud/" class="nav-link">微服务</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/slowside45" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </div> <div class="page"> <div class="content"><p>[TOC]</p> <h2 id="一、js中实现异步的方法"><a href="#一、js中实现异步的方法" aria-hidden="true" class="header-anchor">#</a> 一、JS中实现异步的方法</h2> <ol><li>回调函数</li> <li>Promise对象</li> <li>Thunk函数</li> <li>co模块</li></ol> <h2 id="二、generator函数"><a href="#二、generator函数" aria-hidden="true" class="header-anchor">#</a> 二、Generator函数</h2> <h3 id="_1-运行流程"><a href="#_1-运行流程" aria-hidden="true" class="header-anchor">#</a> 1. 运行流程</h3> <p>Generator是一个封装的异步任务，或者说是异步任务的容器。
它的执行通过两个方法控制：</p> <div class="language- extra-class"><pre class="language-text"><code>1. field
2. next
yield语句表示暂停，next表示下一步。
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>function* gen(x){
    var y =  yield x + 2;
    return y;
}
//调用该Generator函数
var g = gen(1);
g.next();
g.next();
</code></pre></div><p>调用Generator函数，不会返回return值，而是会返回一个指针对象。使用next方法可以让指针向后移动到第一个遇到的yield语句。</p> <div class="language- extra-class"><pre class="language-text"><code>graph TD
A[开始] --&gt; B[Generator函数执行]
B --&gt; P[返回指针对象g]
P --&gt; C[使用指针对象g的next方法]
C --&gt;|指针向后移动| D[到达第一个yield语句 x+2]
D --&gt; E[返回包含当前阶段信息的对象]
E --&gt; F[暂停]
</code></pre></div><p>==包含当前阶段信息的对象==</p> <div class="language- extra-class"><pre class="language-text"><code>g.next();
//返回一个包含当前阶段信息的对象，包括value属性和done属性
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>graph TD
A[对象] --&gt; B[value]
A --&gt; C[done]
B --&gt; E[yield后面表达式的值]
C --&gt; F[是否执行完毕]
</code></pre></div><h3 id="_2-执行器"><a href="#_2-执行器" aria-hidden="true" class="header-anchor">#</a> 2. 执行器</h3> <p>Generator函数是异步方法的封装，它们如果需要被应用到实际情况中，就需要满足在特定条件下能够自动运行。执行器能实现这样的功能。</p> <h4 id="_1-thunk-函数的自动流程管理"><a href="#_1-thunk-函数的自动流程管理" aria-hidden="true" class="header-anchor">#</a> (1). Thunk 函数的自动流程管理</h4> <p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p> <div class="language- extra-class"><pre class="language-text"><code>function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  }

  next();
}

function* g() {
  // ...
}

run(g);
</code></pre></div><p>上面代码的run函数，就是一个 Generator 函数的自动执行器。内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。</p> <p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk 函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var g = function* (){
  var f1 = yield readFileThunk('fileA');
  var f2 = yield readFileThunk('fileB');
  // ...
  var fn = yield readFileThunk('fileN');
};

run(g);
</code></pre></div><p>上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p> <p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p> <h4 id="_2-co模块"><a href="#_2-co模块" aria-hidden="true" class="header-anchor">#</a> (2). co模块</h4> <p>co模块规定，yield后面的语句必须是thunk函数或者promise对象</p> <div class="language- extra-class"><pre class="language-text"><code>//Generator函数
var gen = function* () {
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
//引入co模块
var co = require('co');
co(gen);
</code></pre></div><p>上面代码中，Generator 函数只要传入co函数，就会自动执行。</p> <p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>co(gen).then(function (){
  console.log('Generator 函数执行完成');
});
</code></pre></div><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p> <h2 id="三、-async函数"><a href="#三、-async函数" aria-hidden="true" class="header-anchor">#</a> 三、 async函数</h2> <p>async函数，是Generator函数的语法糖，它的实现原理，就是将Generator函数和它的自动执行器打包在同一个函数里。</p> <div class="language- extra-class"><pre class="language-text"><code>async function f(args){
    // ...
}
</code></pre></div><p>等同于</p> <div class="language- extra-class"><pre class="language-text"><code>function f(args){
    return spawn(function* (){
        // ...
    });
}
</code></pre></div><p>其中spawn函数就可以看作Generetor函数的自动执行器。</p> <h3 id="_1-对generetor的改进"><a href="#_1-对generetor的改进" aria-hidden="true" class="header-anchor">#</a> 1. 对Generetor的改进</h3> <h5 id="_1-内置执行器"><a href="#_1-内置执行器" aria-hidden="true" class="header-anchor">#</a> (1) 内置执行器</h5> <h5 id="_2-更好的语义"><a href="#_2-更好的语义" aria-hidden="true" class="header-anchor">#</a> (2) 更好的语义</h5> <h5 id="_3-await命令后面可以跟promise对象，也可以跟原始类型对象-这时为"><a href="#_3-await命令后面可以跟promise对象，也可以跟原始类型对象-这时为" aria-hidden="true" class="header-anchor">#</a> (3) await命令后面可以跟Promise对象，也可以跟原始类型对象(这时为)</h5> <h5 id="_4-返回值是promise对象，可以用then-方法指定下一步的操作"><a href="#_4-返回值是promise对象，可以用then-方法指定下一步的操作" aria-hidden="true" class="header-anchor">#</a> (4) 返回值是Promise对象，可以用then()方法指定下一步的操作</h5> <h3 id="_2-使用注意点"><a href="#_2-使用注意点" aria-hidden="true" class="header-anchor">#</a> 2. 使用注意点</h3> <h5 id="_1-最好把await命令放在-try-catch语句块中"><a href="#_1-最好把await命令放在-try-catch语句块中" aria-hidden="true" class="header-anchor">#</a> (1) 最好把await命令放在 try-catch语句块中</h5> <h5 id="_2-多个await命令后面的异步操作，如果不存在继发关系，最好让它们同步触发。"><a href="#_2-多个await命令后面的异步操作，如果不存在继发关系，最好让它们同步触发。" aria-hidden="true" class="header-anchor">#</a> (2) 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同步触发。</h5> <div class="language- extra-class"><pre class="language-text"><code>let foo = await function getFoo();
let bar = await function getBar();
</code></pre></div><p>这两个方法互不影响，完全可以同时触发：</p> <div class="language- extra-class"><pre class="language-text"><code>///方法一
let [foo,bar] = await Promise.all([getFoo()],[getBar()]);

//方法二
let fooPromise =  getFoo();
let barPromise =  getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre></div><p>方法二让getFoo()和getBar()同时触发，然后异步保存了它们的返回值(Promise对象)</p> <h5 id="_3-await命令只能用在async函数中"><a href="#_3-await命令只能用在async函数中" aria-hidden="true" class="header-anchor">#</a> (3)await命令只能用在async函数中</h5> <h3 id="_3-异步遍历器-asynciterat"><a href="#_3-异步遍历器-asynciterat" aria-hidden="true" class="header-anchor">#</a> 3. 异步遍历器(asynciterat)</h3> <h5 id="_1-异步遍历器的创建"><a href="#_1-异步遍历器的创建" aria-hidden="true" class="header-anchor">#</a> (1) 异步遍历器的创建</h5> <div class="language- extra-class"><pre class="language-text"><code>//创建一个可以被异步遍历的对象
const asyncIterable = createAsyncIterable(['a','b']);

//创建一个异步遍历器
const asyncIterator = asyncIterator = asyncIterable[Symbol.asyncIterator]();

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>graph LR 
A[asynciterator] --&gt;|调用next方法| B[Promise对象]
B --&gt; C[调用then方法]
C --&gt;|返回value和result| D[处理返回值]
</code></pre></div><h5 id="_2-使用异步遍历器"><a href="#_2-使用异步遍历器" aria-hidden="true" class="header-anchor">#</a> (2) 使用异步遍历器</h5> <div class="language- extra-class"><pre class="language-text"><code>asynvIterator.next().then(iterResult1 =&gt; {
    console.log(iterResult1);
    return asyncIterator.next();//返回一个Promise对象 
    
}).then(iterResult2 =&gt; {
    .....
})........
</code></pre></div><p>因为异步遍历器的next方法返回的是一个Promise对象，所以可以把它们放在await语句后</p> <div class="language- extra-class"><pre class="language-text"><code>async function f() {
  const asyncIterable = createAsyncIterable(['a', 'b']);
  const asyncIterator = asyncIterable[Symbol.asyncIterator]();
  console.log(await asyncIterator.next());
  // { value: 'a', done: false }
  console.log(await asyncIterator.next());
  // { value: 'b', done: false }
  console.log(await asyncIterator.next());
  // { value: undefined, done: true }
}   
</code></pre></div><p>注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 Promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。</p> <div class="language- extra-class"><pre class="language-text"><code>const asyncGenObj = createAsyncIterable(['a', 'b']);
const [{value: v1}, {value: v2}] = await Promise.all([
  asyncGenObj.next(), asyncGenObj.next()
]);

console.log(v1, v2); // a b
</code></pre></div><p>另一种用法是一次性调用所有的next方法，然后await最后一步操作。</p> <div class="language- extra-class"><pre class="language-text"><code>async function runner() {
  const writer = openFile('someFile.txt');
  writer.next('hello');
  writer.next('world');
  await writer.return();
}

runner();
</code></pre></div><h5 id="_3-for-await-of"><a href="#_3-for-await-of" aria-hidden="true" class="header-anchor">#</a> (3)for await... of</h5> <ul><li>新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>async function f() {
  for await (const x of createAsyncIterable(['a', 'b'])) {
    console.log(x);
  }
}
// a
// b
</code></pre></div><ul><li>for await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let body = '';

async function f() {
  for await(const data of req) body += data;
  const parsed = JSON.parse(body);
  console.log('got', parsed);
}
</code></pre></div><p>上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。</p> <ul><li>如果next方法返回的 Promise 对象被reject，for await...of就会报错，要用try...catch捕捉。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>async function () {
  try {
    for await (const x of createRejectingIterable()) {
      console.log(x);
    }
  } catch (e) {
    console.error(e);
  }
}
</code></pre></div><ul><li>注意，for await...of循环也可以用于同步遍历器。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(async function () {
  for await (const x of ['a', 'b']) {
    console.log(x);
  }
})();
// a
// b
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/18.9a24a91a.js" defer></script><script src="/assets/js/app.6496ed3f.js" defer></script>
  </body>
</html>
