(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{342:function(t,a,e){"use strict";e.r(a);var r=e(1),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("p",[t._v("[TOC]")]),t._v(" "),e("h2",{attrs:{id:"一、es6模块加载机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、es6模块加载机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、ES6模块加载机制")]),t._v(" "),e("p",[t._v("ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6模块本身，因为它不是对象。")]),t._v(" "),e("h2",{attrs:{id:"二、严格模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、严格模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、严格模式")]),t._v(" "),e("p",[t._v('ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。')]),t._v(" "),e("p",[t._v("严格模式主要有以下限制。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用with语句\n不能对只读属性赋值，否则报错\n不能使用前缀 0 表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量delete prop，会报错，只能删除属性delete global[prop]\neval不会在它的外层作用域引入变量\neval和arguments不能被重新赋值\narguments不会自动反映函数参数的变化\n不能使用arguments.callee\n不能使用arguments.caller\n禁止this指向全局对象\n不能使用fn.caller和fn.arguments获取函数调用的堆栈\n增加了保留字（比如protected、static和interface）\n")])])]),e("ul",[e("li",[t._v("其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。")])]),t._v(" "),e("h2",{attrs:{id:"三、export命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、export命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、export命令")]),t._v(" "),e("ul",[e("li",[t._v("export命令规定的必须是可以对外的接口，其必须与模块内变量建立一一对应的关系。")]),t._v(" "),e("li",[t._v("export命令必须出现在模块的顶层位置，不能在方法里，或者类里。")])]),t._v(" "),e("h4",{attrs:{id:"_1-变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-变量","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 变量")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n")])])]),e("p",[t._v("上面两种写法都会报错，因为没有提供对外的接口.1只是一个值，不是接口。正确的写法，应该设置一个对外的接口。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n")])])]),e("h4",{attrs:{id:"_2-function和class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-function和class","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. function和class")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 报错\nfunction f() {}\nexport f;\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n")])])]),e("p",[t._v("export语句输出的接口，与其对应的值是动态绑定关系，通过该接口，可以取到模块内部实时的值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n")])])]),e("p",[t._v("上面代码输出变量foo，值为bar，500 毫秒之后变成baz。")]),t._v(" "),e("h4",{attrs:{id:"_3-export-default"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-export-default","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. export default")]),t._v(" "),e("ul",[e("li",[t._v("该命令可以为模块指定默认输出。在使用import命令导入时，就可以用任意名称指向export输出的对象（或属性）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// export-default.js\nexport default function () {\n  console.log('foo');\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n")])])]),e("ul",[e("li",[t._v("该命令在一个模块中只能用一次")]),t._v(" "),e("li",[t._v("本质上是输出了一个被声明的，名为default的变量，所以它后面不能跟变量声明语句。")]),t._v(" "),e("li",[t._v("使用default命令的输出，在对应的import中不需要用｛｝括起来，如果是普通的export，需要用｛｝括起来")])]),t._v(" "),e("h2",{attrs:{id:"四、import-from-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、import-from-命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、import...from...命令")]),t._v(" "),e("h4",{attrs:{id:"_1-导入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-导入","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 导入")]),t._v(" "),e("ul",[e("li",[t._v("使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// main.js\nimport {firstName, lastName, year} from './profile.js';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n")])])]),e("ul",[e("li",[t._v("import导入的变量是只读类型，其值不可修改，其名字可用as命令修改。如果导入的是对象，可以修改对象的属性值。但是建议把import导入的变量都当做只读变量，不去修改。")]),t._v(" "),e("li",[t._v("import命令具有提升效果，会自动提升到模块顶部")]),t._v(" "),e("li",[t._v("import命令中不能使用表达式和==在import之前==没被赋值的变量")])]),t._v(" "),e("h4",{attrs:{id:"适用场合。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场合。","aria-hidden":"true"}},[t._v("#")]),t._v(" 适用场合。")]),t._v(" "),e("h5",{attrs:{id:"（1）按需加载。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（1）按需加载。","aria-hidden":"true"}},[t._v("#")]),t._v(" （1）按需加载。")]),t._v(" "),e("p",[t._v("import()可以在需要的时候，再加载某个模块。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("button.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n")])])]),e("p",[t._v("上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。")]),t._v(" "),e("h5",{attrs:{id:"（2）条件加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（2）条件加载","aria-hidden":"true"}},[t._v("#")]),t._v(" （2）条件加载")]),t._v(" "),e("p",[t._v("import()可以放在if代码块，根据不同的情况，加载不同的模块。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("if (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n")])])]),e("p",[t._v("上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。")]),t._v(" "),e("h5",{attrs:{id:"（3）动态的模块路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（3）动态的模块路径","aria-hidden":"true"}},[t._v("#")]),t._v(" （3）动态的模块路径")]),t._v(" "),e("p",[t._v("import()允许模块路径动态生成。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import(f())\n.then(...);\n")])])]),e("p",[t._v("上面代码中，根据函数f的返回结果，加载不同的模块。")]),t._v(" "),e("h2",{attrs:{id:"五、export和import的复合写法-export-from"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、export和import的复合写法-export-from","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、export和import的复合写法 -- export...from...")]),t._v(" "),e("p",[t._v("如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n")])])]),e("h2",{attrs:{id:"六、模块的继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、模块的继承","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、模块的继承")]),t._v(" "),e("ul",[e("li",[t._v("在子模块中输入export...from '父模块名称'")])])])}],!1,null,null,null);s.options.__file="ES6学习笔记（八）Module的语法.md";a.default=s.exports}}]);