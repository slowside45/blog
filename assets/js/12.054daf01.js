(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{362:function(a,t,e){"use strict";e.r(t);var n=e(1),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("p",[a._v("[TOC]")]),a._v(" "),e("h2",{attrs:{id:"let语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let语句","aria-hidden":"true"}},[a._v("#")]),a._v(" let语句")]),a._v(" "),e("h3",{attrs:{id:"_1-声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-声明","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 声明")]),a._v(" "),e("h6",{attrs:{id:"es6-新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。","aria-hidden":"true"}},[a._v("#")]),a._v(" ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n")])])]),e("hr"),a._v(" "),e("h3",{attrs:{id:"_2-for循中的let"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-for循中的let","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.for循中的let")]),a._v(" "),e("p",[a._v("在for循环中，若在设置循环次数变量时，用let声明，该变量就只在本轮循环有效，每一次的循环，都会有一个新的变量i。")]),a._v(" "),e("h5",{attrs:{id:"用var声明循环变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用var声明循环变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 用var声明循环变量")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n")])])]),e("ul",[e("li",[a._v("因为变量i是用var声明的，所以全局只有一个i,每一次循环，i的值都会发生变化。a[i]中和console.log(i)中的i指向的是同一个i。")]),a._v(" "),e("li",[a._v("循环结束后数组a的值是方法console.log(i)的返回值，该返回值在循环结束后是10")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("graph TD\nA[数组a中的每个元素] --\x3e B[i]\n")])])]),e("h5",{attrs:{id:"用let声明循环体内部变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用let声明循环体内部变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 用let声明循环体内部变量")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = [];\nfor (let i=0; i < 10; i++){\n    a[i] = function () {\n        console.log(i);\n    };\n}\na[6](); //6\n")])])]),e("ul",[e("li",[e("p",[a._v("这里使用let来声明变量i，则每次循环都会有一个新的变量i，数组a中每个元素指向一个不同的变量i。")])]),a._v(" "),e("li",[e("p",[a._v("JS的引擎会自动存储上一轮循环的值，初始化本轮i的值时，就在上一轮的值的基础上继续计算")])])]),a._v(" "),e("h3",{attrs:{id:"_3-在for循环中，循环变量和循环体内部变量有独立的作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-在for循环中，循环变量和循环体内部变量有独立的作用域","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 在for循环中，循环变量和循环体内部变量有独立的作用域")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("for (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n")])])]),e("p",[a._v("设置循环的部分是父作用域，循环体内部是子作用域。父作用域会被子作用域覆盖。")]),a._v(" "),e("h3",{attrs:{id:"_4-不存在变量提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-不存在变量提升","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.不存在变量提升")]),a._v(" "),e("p",[a._v("JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。")]),a._v(" "),e("ul",[e("li",[a._v("在非严格模式下，变量和其赋值都会被提升到顶部")]),a._v(" "),e("li",[a._v("在严格模式下，只有变量的声明会被提升到顶部，其赋值不会被提升到顶部。")])]),a._v(" "),e("p",[a._v("使用var命令，可以使变量在被声明之前被使用，只不过值是undefined。\n在ES6中，必须先用let声明对象后，再使用变量。否则会报错ReferenceError。")]),a._v(" "),e("h3",{attrs:{id:"_5-暂时性死区-tdz"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-暂时性死区-tdz","aria-hidden":"true"}},[a._v("#")]),a._v(" 5. 暂时性死区 TDZ")]),a._v(" "),e("p",[a._v("只要在块级作用域中出现let命令，它所声明的变量就绑定了该作用域，在该let命令声明变量前不得使用该变量，即便是在块级作用域外部已经声明过也不行。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("if (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n")])])]),e("h3",{attrs:{id:"_6-不允许重复声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-不允许重复声明","aria-hidden":"true"}},[a._v("#")]),a._v(" 6. 不允许重复声明")]),a._v(" "),e("ul",[e("li",[a._v("let不允许在相同作用域内，重复声明同一个变量。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 报错\nfunction func() {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction func() {\n  let a = 10;\n  let a = 1;\n}\n")])])]),e("ul",[e("li",[a._v("因此，不能在函数内部重新声明参数。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n")])])]),e("ul",[e("li",[a._v("内层作用域可以定义外层作用域的同名变量。这样的情况，不属于重复声明变量。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("{{{{\n  let insane = 'Hello World';\n  {let insane = 'Hello World'}\n}}}};\n")])])]),e("h3",{attrs:{id:"_7-块级作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-块级作用域","aria-hidden":"true"}},[a._v("#")]),a._v(" 7.块级作用域")]),a._v(" "),e("ul",[e("li",[a._v("由于let的作用域仅在当前块级内，不同的块级作用域分离。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n")])])]),e("ul",[e("li",[e("p",[a._v("上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。")])]),a._v(" "),e("li",[e("p",[a._v("在块级作用域内声明函数，需注意两点：")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1. 写成函数表达式，而不是函数声明语句\n// 函数声明语句\n{\n  let a = 'secret';\n  function f() {\n    return a;\n  }\n}\n\n// 函数表达式\n{\n  let a = 'secret';\n  let f = function () {\n    return a;\n  };\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("2. 函数体外部一定要嵌套大括号\n// 不报错\n'use strict';\nif (true) {\n  function f() {}\n}\n\n// 报错\n'use strict';\nif (true)\n  function f() {}\n")])])]),e("h2",{attrs:{id:"const命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#const命令","aria-hidden":"true"}},[a._v("#")]),a._v(" const命令")]),a._v(" "),e("h3",{attrs:{id:"_1-声明-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-声明-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.声明")]),a._v(" "),e("ul",[e("li",[a._v("一经声明，就必须赋值，否则会报错。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const a;//error\nconst a = 1;\n")])])]),e("ul",[e("li",[a._v("const类型变量，一经声明，不可更改。")]),a._v(" "),e("li",[a._v("其余属性与let相似。")])]),a._v(" "),e("h3",{attrs:{id:"_2-只读属性的本质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-只读属性的本质","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 只读属性的本质")]),a._v(" "),e("p",[a._v("并不是const变量的值不可改变，而是const变量指向的对象所属的内存地址不可改变。")]),a._v(" "),e("ul",[e("li",[a._v("对于简单类型的变量，如字符等，值就保存在变量所指的内存地址。所以可以简单类型的变量可看成常亮。")]),a._v(" "),e("li",[a._v("对于复杂类型的变量，如数组，对象，变量指向的内存地址中，只保存着指针，而指针才指向具体的值，所以const命令只能保证这个内存地址中的指针不变，而不能保证指针所指的具体值不变。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('Eg1:\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: "foo" is read-only\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Eg2:\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n")])])]),e("h2",{attrs:{id:"顶层对象的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#顶层对象的属性","aria-hidden":"true"}},[a._v("#")]),a._v(" 顶层对象的属性")]),a._v(" "),e("p",[a._v("用var声明全局变量等同于为顶层对象的属性赋值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 1;\nwindow.a; //1\n")])])]),e("p",[a._v("用let,const声明全局变量，不等同于为顶层对象的属性赋值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let b = 1;\nwindow.b; //undefined\nconst c = 1；\nwindow.c; //undefined\n")])])]),e("h2",{attrs:{id:"global对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#global对象","aria-hidden":"true"}},[a._v("#")]),a._v(" global对象")]),a._v(" "),e("p",[e("strong",[a._v("顶层对象")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("graph LR\nA[浏览器] --\x3e B[window]\nD[node] --\x3e C[global]\n")])])])])}],!1,null,null,null);s.options.__file="ES6学习笔记（一） let与const命令.md";t.default=s.exports}}]);