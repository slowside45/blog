(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{340:function(a,t,e){"use strict";e.r(t);var s=e(1),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("p",[a._v("[TOC]")]),a._v(" "),e("h2",{attrs:{id:"解构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解构","aria-hidden":"true"}},[a._v("#")]),a._v(" 解构")]),a._v(" "),e("p",[a._v("ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。")]),a._v(" "),e("h3",{attrs:{id:"_1-基本用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本用法","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 基本用法")]),a._v(" "),e("p",[e("strong",[a._v("要义：")])]),a._v(" "),e("ul",[e("li",[a._v("模式匹配")]),a._v(" "),e("li",[a._v("等号左边的对象个数 >= 等号右边的变量个数")]),a._v(" "),e("li",[a._v("等号右边的变量需要具有Iterator接口（可迭代结构）")])]),a._v(" "),e("h3",{attrs:{id:"_2-解构类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解构类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 解构类型")]),a._v(" "),e("h5",{attrs:{id:"_1-完全解构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-完全解构","aria-hidden":"true"}},[a._v("#")]),a._v(" (1)完全解构")]),a._v(" "),e("p",[a._v("等号两边只要模式匹配，就能从对应的位置提取值，对变量进行赋值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [a,b,c] = [0,1,2];\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [a,[b,[c]]] = [0,[1,[2]]]; //a=0,[b,[c]] = [1,[2]]; \n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [startPar, ...endPar] = [0,1,2]; // startPar = 0; endPar = [1,2]\n...是占位符，表示出了第一个变量后面的所有变量\n")])])]),e("h5",{attrs:{id:"_2-解构不成功"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解构不成功","aria-hidden":"true"}},[a._v("#")]),a._v(" (2)解构不成功")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x,y, ...z] = [\"a\"]; /*x = 'a';y=undefined(没有对应的位置给y赋值)\n                           z = [];(...z表示第一个值后的所有值)*/\n")])])]),e("p",[a._v("若解构不成功，则没有在对应位置给等号右边的变量赋值，变量的值将会是undefined.")]),a._v(" "),e("h5",{attrs:{id:"_3-不完全解构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-不完全解构","aria-hidden":"true"}},[a._v("#")]),a._v(" (3)不完全解构")]),a._v(" "),e("p",[a._v("等号左边只有一部分匹配等号右边的模式，这时也能完成解构。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x,y] = [1,2,3]; //x=1;y=2\n")])])]),e("h5",{attrs:{id:"_4-不可迭代的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-不可迭代的数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" (4)不可迭代的数据类型")]),a._v(" "),e("p",[a._v("如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n")])])]),e("p",[a._v("上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。")]),a._v(" "),e("h3",{attrs:{id:"_3-默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-默认值","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 默认值")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("解构赋值允许设置默认值。")])]),a._v(" "),e("li",[e("strong",[a._v("只有等号右边的数组成员变量 === undifined，默认值才会生效")])]),a._v(" "),e("li",[e("strong",[a._v("当等号右边变量为等号左边数组成员赋值时，默认值失效")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n")])])]),e("p",[a._v("上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x=1,y=x] = [2]; //x=2;y=2;\n")])])]),e("p",[a._v("上面代码中，默认值可以引用解构赋值了的其他变量，前提是其他变量已经被声明。")]),a._v(" "),e("p",[a._v("而在等号右边，2被赋给了x，x=1（默认值）将不会生效。")]),a._v(" "),e("h3",{attrs:{id:"_4-对象的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-对象的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" 4. 对象的解构赋值")]),a._v(" "),e("p",[a._v("要义：")]),a._v(" "),e("ul",[e("li",[a._v("键值对 -- 等号左右变量名称对应方可赋值, 次序可以不一致")])]),a._v(" "),e("h5",{attrs:{id:"（1）名称不对应的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（1）名称不对应的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" （1）名称不对应的解构赋值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('let { baz } = { foo: "aaa", bar: "bbb" };\nbaz // undefined\n')])])]),e("p",[a._v("上面代码中，baz是匹配模式，变量中没有与之对应的变量。所以baz取不到值，解构失败。")]),a._v(" "),e("p",[a._v("如果变量名与属性名不一致，必须写成下面这样。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n")])])]),e("p",[a._v("对象的解构赋值是下面形式的简写。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };\n')])])]),e("hr"),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('let { foo: baz } = { foo: "aaa", bar: "bbb" };\nbaz // "aaa"\nfoo // error: foo is not defined\n')])])]),e("p",[a._v("上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。")]),a._v(" "),e("p",[a._v('==可以理解为：foo是类，baz是对象，等号右边的foo:"aaa"是 baz = aaa;==')]),a._v(" "),e("h5",{attrs:{id:"_2-默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-默认值","aria-hidden":"true"}},[a._v("#")]),a._v(" (2)默认值")]),a._v(" "),e("p",[a._v("对象的解构也可以指定默认值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5，这个代码中，x是匹配模式，y是变量，等号右边其实是给y赋值，所以最后y=5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n")])])]),e("p",[a._v("默认值生效的条件是，对象的属性值严格等于undefined。")]),a._v(" "),e("h5",{attrs:{id:"（3）解构提前声明好的变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（3）解构提前声明好的变量","aria-hidden":"true"}},[a._v("#")]),a._v(" （3）解构提前声明好的变量")]),a._v(" "),e("p",[a._v("如果要将一个已经声明的变量用于解构赋值，必须非常小心。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n")])])]),e("ul",[e("li",[a._v("上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 正确的写法\nlet x;\n({x} = {x: 1});\n")])])]),e("h5",{attrs:{id:"_4-等号左边的模式中不放置任何变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-等号左边的模式中不放置任何变量","aria-hidden":"true"}},[a._v("#")]),a._v(" (4)等号左边的模式中不放置任何变量")]),a._v(" "),e("ul",[e("li",[a._v("在等号左边，只写模式，不写对应的变量。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("({} = [true, false]);\n({} = 'abc');\n({} = []);\n")])])]),e("ul",[e("li",[a._v("上面的表达式虽然毫无意义，但是语法是合法的，可以执行。\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let { log, sin, cos } = Math;\n")])])]),e("ul",[e("li",[a._v("上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。")])]),a._v(" "),e("h5",{attrs:{id:"_5-数组的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-数组的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" (5)数组的解构赋值")]),a._v(" "),e("p",[a._v("数组本质是特殊的对象，因此可以对数组进行对象属性的解构。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n0 --\x3e 1; 1 --\x3e 2; 2 --\x3e 3\n")])])]),e("p",[a._v("上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3.")]),a._v(" "),e("h5",{attrs:{id:"_6-字符串的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-字符串的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" (6)字符串的解构赋值")]),a._v(" "),e("ul",[e("li",[a._v("字符串在被解构赋值时，实际上是被转换成了一个类似于数组的对象。\n等号左边每一个数组成员变量，根据位置与右边变量一一对应。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const [a,b,c,d,e] = \"hello\";\na // 'h';\nb // 'e';\nc // 'l';\nd // 'l';\ne // 'o';\n")])])]),e("ul",[e("li",[a._v("类似数组的对象都有一个length属性，可以对这个属性解构赋值：")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let {length: len} = 'hello';\nlen //5;\n")])])]),e("h5",{attrs:{id:"_7-数值和布尔值的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-数值和布尔值的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" (7)数值和布尔值的解构赋值")]),a._v(" "),e("ul",[e("li",[a._v("解构赋值中，如果等号右边的变量不是对象，就会将它们先转换成变量，再进行解构赋值。")])]),a._v(" "),e("h5",{attrs:{id:"_8-函数参数的解构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-函数参数的解构","aria-hidden":"true"}},[a._v("#")]),a._v(" (8)函数参数的解构")]),a._v(" "),e("p",[a._v("==Map方法的用法==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\nmap() 方法按照原始数组元素顺序依次处理元素。\n注意： map() 不会对空数组进行检测。\n注意： map() 不会改变原始数组。\n")])])]),e("p",[a._v("==解构函数的参数==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n")])])]),e("ul",[e("li",[e("p",[a._v("在这个例子中，([a,b]) => a+b 等同于 function([a,b]){ return a+b; }")])]),a._v(" "),e("li",[e("p",[a._v("map方法的作用是改变前面的数组，经过函数处理后，返回一个新数组。")])])]),a._v(" "),e("h5",{attrs:{id:"_9-不能使用圆括号的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-不能使用圆括号的解构赋值","aria-hidden":"true"}},[a._v("#")]),a._v(" (9)不能使用圆括号的解构赋值")]),a._v(" "),e("p",[a._v("==① 变量声明语句==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 全部报错\nlet [(a)] = [1];\n\nlet {x: (c)} = {};\nlet ({x: c}) = {};\nlet {(x: c)} = {};\nlet {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n")])])]),e("p",[a._v("上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。")]),a._v(" "),e("p",[a._v("==② 函数参数==")]),a._v(" "),e("p",[a._v("函数参数也属于变量声明，因此不能带有圆括号。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n")])])]),e("p",[a._v("==③ 赋值语句的模式==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n上面代码将整个模式放在圆括号之中，导致报错。\n\n// 报错\n[({ p: a }), { x: c }] = [{}, {}];\n上面代码将一部分模式放在圆括号之中，导致报错。\n")])])]),e("h5",{attrs:{id:"_10-可以使用圆括号的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-可以使用圆括号的情况","aria-hidden":"true"}},[a._v("#")]),a._v(" (10)可以使用圆括号的情况")]),a._v(" "),e("ul",[e("li",[a._v("当圆括号内不是模式部分时，不会报错。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n")])])]),e("ul",[e("li",[a._v("第一条，(b)是实际要被赋值的变量，不是模式成员")]),a._v(" "),e("li",[a._v("第二条，同上，模式是p，变量是d")]),a._v(" "),e("li",[a._v("第三条，同上")])]),a._v(" "),e("h3",{attrs:{id:"_5-解构赋值的实际用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-解构赋值的实际用法","aria-hidden":"true"}},[a._v("#")]),a._v(" 5. 解构赋值的实际用法")]),a._v(" "),e("h5",{attrs:{id:"_1-交换两个变量的值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-交换两个变量的值","aria-hidden":"true"}},[a._v("#")]),a._v(" (1)交换两个变量的值")]),a._v(" "),e("p",[a._v("在ES6中：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let x = 1;\nlet y = 2;\n[x,y] = [y,x];\n")])])]),e("p",[a._v("在普通js中：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var x = 1;\nvar y = 2;\nvar cache;\nvar cache = x;\nvar x = y;\nvar y = cache;\n")])])]),e("p",[a._v("==相比较起来，ES6中的解构赋值功能让代码更清晰，简洁==")]),a._v(" "),e("h5",{attrs:{id:"_2-从函数返回多个值后，接收这些值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-从函数返回多个值后，接收这些值","aria-hidden":"true"}},[a._v("#")]),a._v(" (2)从函数返回多个值后，接收这些值")]),a._v(" "),e("p",[a._v("在ES6中:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function eg(){\n    return [1,2,3];\n}\nlet [a,b,c] = eg(); //接收起来很简单,abc都有了自己对应的值\n")])])]),e("p",[a._v("在普通js中：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function eg(){\n    return [1,2,3]\n}\nvar arr[] = eg();\nvar a = arr[0];\nvar b = arr[1];\nvar c = arr[2];  //接收需要从数组里挨个取值\n")])])]),e("h5",{attrs:{id:"_3-调用函数时，给函数传参"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-调用函数时，给函数传参","aria-hidden":"true"}},[a._v("#")]),a._v(" (3)调用函数时，给函数传参")]),a._v(" "),e("p",[a._v("在ES6中：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function eg([x,y,z]){...}\neg([1,2,3]);\n\neg({z:3,y=2,x=1})\n")])])]),e("ul",[e("li",[a._v("上面做了两种不一样的函数调用，第二种是无序地传入参数。")])]),a._v(" "),e("p",[a._v("在普通js中：\n只能有序地传入参数")]),a._v(" "),e("h5",{attrs:{id:"_4-取json数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-取json数据","aria-hidden":"true"}},[a._v("#")]),a._v(" (4)取JSON数据")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let jsonData = {\n    id: 1,\n    status: 'OK',\n    date: [2018,6]\n}\n\nlet {id,status,date} = jsonData;\nconsole.log(id,status,date); \n")])])]),e("p",[a._v("==结果为：id=1;status='OK',date=[2018,6]==")]),a._v(" "),e("h5",{attrs:{id:"_5-为函数参数设定默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-为函数参数设定默认值","aria-hidden":"true"}},[a._v("#")]),a._v(" (5)为函数参数设定默认值")]),a._v(" "),e("p",[a._v("==1. 给参数设定默认值后，就不用再在函数内做配置。==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jQuery.ajax() = function (url,{\n    async = true,\n    beforeSend() = function(){},\n    cache = true,\n    complete = function(){},\n    crossDomail = false,\n    global = true\n    //...更多配置\n} = {}) {\n    //函数执行方法...\n}\n")])])]),e("p",[a._v("==2. 对比两种不同写法，在传参不同的情况下，函数的输出值==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n")])])]),e("p",[a._v("上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// x 和 y 都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x 有值，y 无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n")])])]),e("p",[a._v("==3. 参数默认值的位置==")]),a._v(" "),e("ul",[e("li",[a._v("通常情况下，应该给函数的尾参数定义默认值，因为这样比较容易看出来省略了哪些参数。如果非尾部的参数被设定了默认值，则不能在调用函数，传参时省略它。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function f(x=1,y){\n    return [x,y]\n}\nf() //[1,undefined]\nf(2) //[2,undefined]\nf(, 1) //报错\nf(undefined,1) //[1,1]\n")])])]),e("p",[a._v("==在这些函数中，有默认值的都不是尾参数，所以不能只省略它们，而不省略后面的参数。除非显示输入undefined==")]),a._v(" "),e("h5",{attrs:{id:"_6-遍历map结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-遍历map结构","aria-hidden":"true"}},[a._v("#")]),a._v(" (6)遍历Map结构")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const map = new Map();\nmap.set = {'first','lee'};\nmap.set = {'second','floyd'};\n\nfor (let[key,value] of map){\n    console.log(key + 'is' + value);\n}\n")])])]),e("p",[a._v("输出结果为：first is le /n  second is floyd")]),a._v(" "),e("ul",[e("li",[a._v("只获取key或只获取value:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 只获取键名\nfor (let [key] of map){\n    console.log(key);\n}\n// 只获取键值\nfor (let [,value] of map){\n    console.log(value);\n}\n")])])])])}],!1,null,null,null);r.options.__file="ES6学习笔记（二） 变量的解构赋值.md";t.default=r.exports}}]);