(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{334:function(r,i,n){"use strict";n.r(i);var v=n(1),t=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var r=this,i=r.$createElement,n=r._self._c||i;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"jvm堆内存的管理机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jvm堆内存的管理机制","aria-hidden":"true"}},[r._v("#")]),r._v(" JVM堆内存的管理机制")]),r._v(" "),n("h3",{attrs:{id:"对象从出生到死亡"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象从出生到死亡","aria-hidden":"true"}},[r._v("#")]),r._v(" 对象从出生到死亡")]),r._v(" "),n("ol",[n("li",[r._v("对象的分配")])]),r._v(" "),n("ul",[n("li",[n("p",[r._v("对象优先分配在Eden区\n当new一个新对象时，JVM会优先将其分配在Eden区，如果Eden区满了，则JVM会发生一次Minor GC。\nMinor GC\n在年轻代空间中执行内存回收叫做Minor GC。当执行Minor GC时，会触发“stop the world”，暂停所有应用的线程，只是对于大部分应用程序来说，时间短暂到可以忽略不计。\nMinor GC会将Eden区还存活的对象和Survivor1区（假设Survivor1不为空，Survivor2为空）中年龄未超过阈值的对象复制到Survivor2区中，然后清空Eden和Survivor1区，始终保持有一个Survivor区为空。")])]),r._v(" "),n("li",[n("p",[r._v("大对象直接进入老年代\n    这里有一个例外的情况：当JVM需要分配大量连续内存空间的对象时（最典型的就是很长的字符串或数组），会直接将它们放入放入老年代中，原因是避免在Eden区和两个Survivor区中发生大量的内存复制（年轻代采用复制算法，老年代采用标记-清除、标记-整理，处理大对象快）。\n    通过参数-XX:PretenureSizeThreshold设置大于此数值的对象直接在老年代分配。")])])]),r._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[r._v("对象的晋升")])]),r._v(" "),n("ul",[n("li",[n("p",[r._v("晋升的阈值\n    在JVM中，给每个对象都定义了一个对象年龄计数器，用来记录每个对象的“年龄”：对象在Eden区出生，每经历一次Minor GC则年龄增加1。当年龄增大到一定程度时，就会晋升到老年代中。这个年龄阈值可以通过参数-XX:MaxTenuringThreshold来设置，默认为15岁。")])]),r._v(" "),n("li",[n("p",[r._v("动态对象年龄判定\n    虚拟机为了更好地判定对象进入老年代的时机，提出了一种例外情况：如果在Survivor区中所有相同年龄的对象数量总和达到了Survivor区大小的一半，则大于或等于该年龄的对象都能直接进入老年代。")])])]),r._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[r._v("对象的回收")])]),r._v(" "),n("ul",[n("li",[n("p",[r._v("Minor GC\n    前面已经介绍过Minor GC，它是针对于年轻代的内存回收，当new一个新对象时Eden区无内存可分配时触发一次Minor GC。")])]),r._v(" "),n("li",[n("p",[r._v("Full GC\n    当Minor GC的时候老年代的空间小于以往的平均晋升对象所需要的空间（即空间分配担保存在风险，空间分配担保可参照下文），JVM就会执行一次Full GC，收集清理包括年轻代和老年代还有永久代在内的无用对象（PS: 这里要特别说明一下，在JDK7及以前永久代即方法区，而在JDK8之后，永久代已经被移除了，取而代之的是元空间，它是存放在本地的一块内存区域，JDK8之后的Full GC应该是包括元空间在内的垃圾回收），所用的算法前文已经提到过，主要有标记-清理和标记-整理，根据具体的虚拟机的不同而不同。")])])]),r._v(" "),n("h3",{attrs:{id:"空间分配担保"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#空间分配担保","aria-hidden":"true"}},[r._v("#")]),r._v(" 空间分配担保")]),r._v(" "),n("p",[r._v("如果在某次Minor GC中Survivor区的容量小于需要进行复制的对象，则会启用分配担保机制：将Eden区和Survivor区的对象都放入老年代，新对象分配进Eden区。\n    但是实际上，空间分配担保也不是每次都能成功的。在每一次Minor GC之前，虚拟机总要检查老年代中最大可连续分配的内存空间是否大于新生代总空间，如果大于，则这是一次安全的Minor GC，直接进行Minor GC。否则的话虚拟机要查看HandlePromotionFailure设置值是否允许担保失败。如果允许，则继续检查老年代的最大可用连续空间是否大于历次晋升到老年代的平均大小，如果是则进行一次有风险的Minor GC。否则如果小于或者之前的设置值不允许则改为进行一次Full GC。")]),r._v(" "),n("h3",{attrs:{id:"jvm调优的基本思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优的基本思路","aria-hidden":"true"}},[r._v("#")]),r._v(" JVM调优的基本思路")]),r._v(" "),n("p",[r._v("如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。基本思路就是让每一次GC都回收尽可能多的对象，\n对于CMS来说，要合理设置年轻代和年老代的大小。该如何确定它们的大小呢？这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。")]),r._v(" "),n("ol",[n("li",[n("p",[r._v("如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。")])]),r._v(" "),n("li",[n("p",[r._v("如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。")])]),r._v(" "),n("li",[n("p",[r._v("对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。")])])])])}],!1,null,null,null);t.options.__file="jvm.md";i.default=t.exports}}]);