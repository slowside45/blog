(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{330:function(t,e,n){"use strict";n.r(e);var s=n(1),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("p",[t._v("[TOC]")]),t._v(" "),n("h2",{attrs:{id:"一、类内的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、类内的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、类内的方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point(){\n    constructor(x,y){\n        this.x = x;\n        this.y = y;\n    }\n    toString(){\n        console.log('param1 is:'+ x + ',' + 'prama2 is:' + y);\n    }\n    toString1(){\n        ...\n    }\n}\n")])])]),n("ul",[n("li",[t._v("constructor()是构造器")]),t._v(" "),n("li",[t._v("toString()和toString1是类内的普通方法，在类内写方法不用逗号分隔。")])]),t._v(" "),n("h2",{attrs:{id:"二、prototype属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、prototype属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、prototype属性")]),t._v(" "),n("ul",[n("li",[t._v("类内的所有方法，都定义在类的prototype属性上")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point {\n  constructor() \n  {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n\n")])])]),n("ul",[n("li",[t._v("使用Object.assign()向类内添加方法")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point(){\n    constructor(){\n        ......\n    }\n}\n\nObject.assign(Point.prototype,{\n   toString(){}, \n   toValue(){},\n});\n")])])]),n("h2",{attrs:{id:"三、类不存在变量提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、类不存在变量提升","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、类不存在变量提升")]),t._v(" "),n("p",[t._v("类不存在变量提升（hoist），这一点与 ES5 完全不同。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("new Foo(); // ReferenceError\nclass Foo {}\n")])])]),n("p",[t._v("上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("{\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n")])])]),n("p",[t._v("上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。")]),t._v(" "),n("h2",{attrs:{id:"四、私有方法和私有属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、私有方法和私有属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、私有方法和私有属性")]),t._v(" "),n("p",[t._v("在属性或者方法名前加上#符号，跟private一个意思.")]),t._v(" "),n("p",[t._v("另外，私有属性也可以设置 getter 和 setter 方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Counter {\n  #xValue = 0;\n\n  get #x() { return #xValue; }\n  set #x(value) {\n    this.#xValue = value;\n  }\n\n  constructor() {\n    super();\n    // ...\n  }\n}\n")])])]),n("h2",{attrs:{id:"五、getter-和-setter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、getter-和-setter","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、getter 和 setter")]),t._v(" "),n("h4",{attrs:{id:"_1-get和set关键字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-get和set关键字","aria-hidden":"true"}},[t._v("#")]),t._v(" (1)get和set关键字")]),t._v(" "),n("p",[t._v("与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n")])])]),n("h4",{attrs:{id:"_2-descriptor属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-descriptor属性","aria-hidden":"true"}},[t._v("#")]),t._v(" (2)Descriptor属性")]),t._v(" "),n("ul",[n("li",[t._v("存值函数和取值函数是设置在属性的 Descriptor 对象上的。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, "html"\n);\n\n"get" in descriptor  // true\n"set" in descriptor  // true\n')])])])])}],!1,null,null,null);a.options.__file="ES6学习笔记（七）Class的基本语法.md";e.default=a.exports}}]);