[TOC]
## 解构
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

### 1. 基本用法
**要义：**
+ 模式匹配 
+ 等号左边的对象个数 >= 等号右边的变量个数
+ 等号右边的变量需要具有Iterator接口（可迭代结构）

### 2. 解构类型
##### (1)完全解构
等号两边只要模式匹配，就能从对应的位置提取值，对变量进行赋值。

```
let [a,b,c] = [0,1,2];
```

```
let [a,[b,[c]]] = [0,[1,[2]]]; //a=0,[b,[c]] = [1,[2]]; 
```
```
let [startPar, ...endPar] = [0,1,2]; // startPar = 0; endPar = [1,2]
...是占位符，表示出了第一个变量后面的所有变量
```
##### (2)解构不成功
```
let [x,y, ...z] = ["a"]; /*x = 'a';y=undefined(没有对应的位置给y赋值)
                           z = [];(...z表示第一个值后的所有值)*/
```
若解构不成功，则没有在对应位置给等号右边的变量赋值，变量的值将会是undefined.

##### (3)不完全解构
等号左边只有一部分匹配等号右边的模式，这时也能完成解构。
```
let [x,y] = [1,2,3]; //x=1;y=2
```
##### (4)不可迭代的数据类型
如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```
上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。

### 3. 默认值
+ **解构赋值允许设置默认值。**
+ **只有等号右边的数组成员变量 === undifined，默认值才会生效**
+ **当等号右边变量为等号左边数组成员赋值时，默认值失效**
```
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
```
上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。

```
let [x=1,y=x] = [2]; //x=2;y=2;
```
上面代码中，默认值可以引用解构赋值了的其他变量，前提是其他变量已经被声明。

而在等号右边，2被赋给了x，x=1（默认值）将不会生效。

### 4. 对象的解构赋值
要义：
+ 键值对 -- 等号左右变量名称对应方可赋值, 次序可以不一致

##### （1）名称不对应的解构赋值
```
let { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined
```
上面代码中，baz是匹配模式，变量中没有与之对应的变量。所以baz取不到值，解构失败。

如果变量名与属性名不一致，必须写成下面这样。
```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```
对象的解构赋值是下面形式的简写。
```
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```
---
```
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```
上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。

==可以理解为：foo是类，baz是对象，等号右边的foo:"aaa"是 baz = aaa;==

##### (2)默认值
对象的解构也可以指定默认值。
```
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5，这个代码中，x是匹配模式，y是变量，等号右边其实是给y赋值，所以最后y=5

var { message: msg = 'Something went wrong' } = {};
msg // "Something went wrong"
```
默认值生效的条件是，对象的属性值严格等于undefined。

##### （3）解构提前声明好的变量
如果要将一个已经声明的变量用于解构赋值，必须非常小心。
```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```
+ 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
```
// 正确的写法
let x;
({x} = {x: 1});
```
##### (4)等号左边的模式中不放置任何变量
+ 在等号左边，只写模式，不写对应的变量。
```
({} = [true, false]);
({} = 'abc');
({} = []);
```
+ 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。
对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
```
let { log, sin, cos } = Math;
```
+ 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。
##### (5)数组的解构赋值
数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
```
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
0 --> 1; 1 --> 2; 2 --> 3
```
上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3.

##### (6)字符串的解构赋值
+ 字符串在被解构赋值时，实际上是被转换成了一个类似于数组的对象。
等号左边每一个数组成员变量，根据位置与右边变量一一对应。
```
const [a,b,c,d,e] = "hello";
a // 'h';
b // 'e';
c // 'l';
d // 'l';
e // 'o';
```
+ 类似数组的对象都有一个length属性，可以对这个属性解构赋值：
```
let {length: len} = 'hello';
len //5;
```
##### (7)数值和布尔值的解构赋值
+ 解构赋值中，如果等号右边的变量不是对象，就会将它们先转换成变量，再进行解构赋值。

##### (8)函数参数的解构
==Map方法的用法==
```
map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
map() 方法按照原始数组元素顺序依次处理元素。
注意： map() 不会对空数组进行检测。
注意： map() 不会改变原始数组。
```
==解构函数的参数==
```
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
```
+ 在这个例子中，([a,b]) => a+b 等同于 function([a,b]){ return a+b; }

+ map方法的作用是改变前面的数组，经过函数处理后，返回一个新数组。

##### (9)不能使用圆括号的解构赋值
==① 变量声明语句==
```
// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
```
上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。

==② 函数参数==

函数参数也属于变量声明，因此不能带有圆括号。
```
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```
==③ 赋值语句的模式==
```
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
上面代码将整个模式放在圆括号之中，导致报错。

// 报错
[({ p: a }), { x: c }] = [{}, {}];
上面代码将一部分模式放在圆括号之中，导致报错。
```                                             

##### (10)可以使用圆括号的情况
+ 当圆括号内不是模式部分时，不会报错。
```
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```
+ 第一条，(b)是实际要被赋值的变量，不是模式成员
+ 第二条，同上，模式是p，变量是d
+ 第三条，同上

### 5. 解构赋值的实际用法
##### (1)交换两个变量的值
在ES6中：
```
let x = 1;
let y = 2;
[x,y] = [y,x];
```
在普通js中：
```
var x = 1;
var y = 2;
var cache;
var cache = x;
var x = y;
var y = cache;
```
==相比较起来，ES6中的解构赋值功能让代码更清晰，简洁==
##### (2)从函数返回多个值后，接收这些值
在ES6中:
```
function eg(){
    return [1,2,3];
}
let [a,b,c] = eg(); //接收起来很简单,abc都有了自己对应的值
```
在普通js中：
```
function eg(){
    return [1,2,3]
}
var arr[] = eg();
var a = arr[0];
var b = arr[1];
var c = arr[2];  //接收需要从数组里挨个取值
```
##### (3)调用函数时，给函数传参
在ES6中：
```
function eg([x,y,z]){...}
eg([1,2,3]);

eg({z:3,y=2,x=1})
```
+ 上面做了两种不一样的函数调用，第二种是无序地传入参数。

在普通js中：
只能有序地传入参数

##### (4)取JSON数据
```
let jsonData = {
    id: 1,
    status: 'OK',
    date: [2018,6]
}

let {id,status,date} = jsonData;
console.log(id,status,date); 
```
==结果为：id=1;status='OK',date=[2018,6]==
##### (5)为函数参数设定默认值
==1. 给参数设定默认值后，就不用再在函数内做配置。==
```
jQuery.ajax() = function (url,{
    async = true,
    beforeSend() = function(){},
    cache = true,
    complete = function(){},
    crossDomail = false,
    global = true
    //...更多配置
} = {}) {
    //函数执行方法...
}
```


==2. 对比两种不同写法，在传参不同的情况下，函数的输出值==
```
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}
```
```
// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
```
上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。
```
// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]
```
```
// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```
==3. 参数默认值的位置==
+ 通常情况下，应该给函数的尾参数定义默认值，因为这样比较容易看出来省略了哪些参数。如果非尾部的参数被设定了默认值，则不能在调用函数，传参时省略它。
```
function f(x=1,y){
    return [x,y]
}
f() //[1,undefined]
f(2) //[2,undefined]
f(, 1) //报错
f(undefined,1) //[1,1]
```
==在这些函数中，有默认值的都不是尾参数，所以不能只省略它们，而不省略后面的参数。除非显示输入undefined==
##### (6)遍历Map结构
```
const map = new Map();
map.set = {'first','lee'};
map.set = {'second','floyd'};

for (let[key,value] of map){
    console.log(key + 'is' + value);
}
```
输出结果为：first is le /n  second is floyd

+ 只获取key或只获取value:
```
// 只获取键名
for (let [key] of map){
    console.log(key);
}
// 只获取键值
for (let [,value] of map){
    console.log(value);
}
```
